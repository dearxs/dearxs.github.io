<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Fira Mono:300,300italic,400,400italic,700,700italic|Alegreya SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yiti.ml","root":"/","scheme":"Pisces","version":"7.7.1","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":"flat"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Khan&#39;s Lab">
<meta property="og:url" content="https://yiti.ml/page/29/index.html">
<meta property="og:site_name" content="Khan&#39;s Lab">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Dali Khan">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://yiti.ml/page/29/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>Khan's Lab</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Khan's Lab" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Khan's Lab</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">Explore & Evolve</p>
  </div>

  <div class="site-nav-right"></div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://yiti.ml/xx036/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Dali Khan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Khan's Lab">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/xx036/" class="post-title-link" itemprop="url">直播：孤獨的狂歡</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-06-26 17:40" itemprop="dateCreated datePublished" datetime="2018-06-26T17:40:24+08:00">2018-06-26</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/opinions/" itemprop="url" rel="index">
                    <span itemprop="name">观点</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>去年年中被網上一個搞笑的視頻吸引，視頻吐槽的是一個大逃殺的遊戲裡面中國玩家自發組織成「紅衫軍」(全部穿上紅色的上衣）追殺其他玩家，配音很搞笑。這個遊戲 <em>H1N1</em>。</p>
<p>後來自己就忍不住在網上買了一臺神舟的筆記本，安裝上 <em>Steam</em>，進入了一個遊戲的世界。購買了 <em> 絕地求生</em>，也就是 <em>Playunknown’s Battleground (PUBG)</em>，98 塊人民幣。</p>
<p>遊戲下載下來，才發現原來國內連上服務器太難，想要玩遊戲的話，還需要購買加速器服務，按月收費。好坑爹。自己玩了一些日子，無奈，太菜了，想想自己高中的時候打 CS 就打的很臭。然後就放棄了遊戲，開始在網上看牛人打遊戲的直播。</p>
<p>這也是我第一次開始看直播。之前心裡總覺得直播這個行當不就是各種網紅臉的小姑娘在鏡頭前扭來扭曲嗎？沒什麼看的。但其實到了這個時候，遊戲直播已將成了遊戲宣傳的一個重要渠道。<em>絕地求生 </em> 這款遊戲火起來也有很大一部分的功勞給直播。</p>
<p>後來各大平台為了吸引觀眾開始爭相舉辦 PUBG 的比賽，一時間幾乎每天都有比賽，各個電競的戰隊也火了起來。這時候，我放棄了之前看的二三流小主播的直播，開始看主流職業隊隊員的直播。喜歡上了<em>4AM</em>。</p>
<p>在直播間，我很少發言，也很少送禮物。看著滿屏的彈幕和各種禮物，也慢慢大概了解了所謂的「直播文化」。<strong>也越來越覺得，直播行業其實就是一群孤獨的人的在線狂歡。</strong></p>
<h2 id="每個人都渴望被聽到，都渴望回應"><a href="# 每個人都渴望被聽到，都渴望回應" class="headerlink" title="每個人都渴望被聽到，都渴望回應"></a>每個人都渴望被聽到，都渴望回應 </h2><p> 直播中的彈幕，是大家的交流空間，很像十幾年前的聊天室，像現在的 QQ 群，微信群，但是直播的彈幕更加實時，是絕對實時的（即時聊天的軟件其實並不是絕對實時的，因為有些人會晚些看到。）所以你就會看到各種各樣的“聳人聽聞”，甚至“不堪入目”的彈幕。所有這些，也都是為了得到大家的關注。要知道，在一屏幕幾十條幾百條一閃而過的彈幕中要脫穎而出是很難的。</p>
<p>另一個獲取主播關注和回應的方式是送禮物。一般的禮物很難得到主播的關注，所以才會有前段時間某會計挪用公款打賞女主播獲取其關注的新聞。女主播會明碼標價，諸如一個佛跳墻加微信，一個龍蝦上房管，三張車票上車（我到現在還沒搞清楚上車是什麼意思）。一個佛跳墻一千塊，直播平台和主播 55 分成的話，也就是人民幣五百塊才可以加美女主播的微信，不得不說，還是挺貴的。但打賞的人大有人在，各種小禮物，中禮物，大禮物送的層出不窮，每個直播平台無一例外會有一個禮物排行榜，包括日榜周榜月榜等等。Ranking 機制讓人類發狂。</p>
<p>注意力是個神奇的東西，現在走在大街上誰又會對陌生人有多餘的關注呢？騰訊最近推的一個 72 小時的記錄片（買的 NHK 的版權），採訪路人，你會發現每個人都有很多故事。是啊，誰還沒有幾個故事了。但是，誰的故事又會有人傾聽呢？</p>
<blockquote>
<p>用繁體只是因為我想試試繁體字在這個網頁的顯示效果，沒有別的意思。對美麗的事情就是無法克制自己的喜歡。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://yiti.ml/fy028/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Dali Khan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Khan's Lab">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/fy028/" class="post-title-link" itemprop="url">《卡片男孩斯坦利》之「万事俱备」</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-06-25 12:38" itemprop="dateCreated datePublished" datetime="2018-06-25T12:38:53+08:00">2018-06-25</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/translate/" itemprop="url" rel="index">
                    <span itemprop="name">翻译</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>《卡片男孩斯坦利》是之前和前女友一起翻译过的几本书中的一本，这里选的是其中一册中的一个小故事。有删减。</p>
</blockquote>
<h2 id="万事俱备"><a href="# 万事俱备" class="headerlink" title="万事俱备"></a>万事俱备 </h2><p> 斯坦利喜欢旅游观光，但他已经等不及要开始自己的任务了。不过，在参加白金汉宫的舞会之前，他还有意见重要的事情要做：挑选舞会要穿的衣服！</p>
<p>第二天一早，兰乔普先生带领他们经过一段长长的自动扶梯，来到了伦敦城的地下，“欢迎来到伦敦地铁！”</p>
<p>亚瑟看了看自己面前的隧道。“我们确实是在地下，但是这里可不像是卖衣服的地方。”爸爸笑了，“那是因为我没还在去商店的路上。”</p>
<p>斯坦利的眼睛慢慢适应了地下的光线之后，他似乎觉察到了什么，这可不是个普通的隧道，这是个地铁的隧道。</p>
<p>“伦敦地铁就是伦敦城的地下公交，有些人称呼它‘管道’（tube）。”爸爸跟他们解释道。</p>
<p>马上斯坦利就感觉到隧道深处吹来一股风，他赶紧抱住亚瑟，好不被风吹走。然后他就看到一列银色的地铁进站了。地铁列车门打开，好多人从上面走了下来。地铁广播发出了警示的声音，“小心缝隙！”</p>
<p>斯坦利听到的是，小心‘奋’隙。广播员和贝茨警长的口音很像。“这广播什么意思啊？”亚瑟问道，“小心什么缝隙？”</p>
<p>“小心列车和站台之间的缝隙”，妈妈跟亚瑟解释道。</p>
<p>斯坦利低头一看，列车和站台之间有一道很窄的缝隙，但是他很轻易就可以掉下去。所以，他很小心翼翼地走上了地铁列车，确保自己不要掉进缝隙里面。然而，除了缝隙之外，他还有一个更大的问题要去面对：车厢里面太拥挤了。每个座位上都有人，座位之间的过道里面也站满了人。人们手扶着车厢里的柱子和横档，他们的扶着柱子的胳膊互相交织，像个迷宫一样；他们站在地上的腿也互相交织，形成了另一张网。</p>
<p>“抱歉”，亚瑟礼貌地说，然后挪到了一个很小的角落。</p>
<p>“不好意思”，兰乔普夫人伸手抓住头顶的扶手的时候，嘴上不停地说。</p>
<p>斯坦利从一位正在翻杂志的女士身旁溜过去，跃过一个放在地上的手提箱，找到一个靠墙的位置。列车开了，斯坦利紧紧地靠在墙上，和墙上的广告海报完美地融为了一体。他并没有觉得不舒服，因为他的身体本来就不占什么空间。</p>
<p>突然，人群中一个人喊了出来，“看！‘卡片男孩’斯坦利要在皇家剧院演出了！”人们全都转头盯着斯坦利。其实他们盯着的是斯坦利身后的海报。</p>
<p>斯坦利转头一看，身后的海报是一个即将上演的演出的广告，斯坦利站在那里，看起来就像是他也会参加那个演出一样。</p>
<p>但是斯坦利这么一转头，人们都发觉了，他们盯着的不是“卡片男孩”斯坦利的照片，而是真真正正的“卡片男孩”斯坦利！</p>
<p>“你真人比我想象的要更加扁‘贫’（平）”，人群里面一个声音说。</p>
<p>“可以给我签个名吗？”人群里另一个声音说。</p>
<p>斯坦利笑了笑，出名以后，他已经习惯了这样的场面。毕竟，他来到伦敦也是因为自己名声在外。没有人会怀疑他来伦敦参加皇室舞会是有一个秘密任务要执行。不过，这次任务太还是有一点遗憾，那就是这次任务跟他“扁平”的身体毫无关系。有时候，他“扁平”的身体可以帮他大忙。但这次的伦敦之旅，似乎跟他“扁平”的身体毫无关系。</p>
<p>列车停了，斯坦利一家人坐着另一个长长的扶梯，穿过一条熙熙攘攘的街，来到了一个叫做“哈罗德百货”（注 1）的商场。商场的玻璃门打开的时候，他们好像来到了一个另一个世界。空气里是香氛的味道，地板干净的发亮。</p>
<blockquote>
<p>注 1: 哈洛德百货（英文：Harrods），世界最负盛名的百货公司，贩售奢华的商品，位于伦敦的骑士桥（Knightsbridge）上，在西敏和肯辛顿之间。</p>
</blockquote>
<p>斯坦利的爸爸——兰乔普先生看了看商场的地图，“这边通向儿童区。”</p>
<p>儿童区里有各种各样漂亮的童装。这些衣服看起来像是电影明星经常穿的一样，斯坦利心想，电视上那些模特穿得好像也是这种。斯坦利觉得这些衣服穿起来肯定不会舒服，他想，要是自己能穿着汗衫和牛仔裤去参加舞会就好了。</p>
<p>“噢，你好！有什么需要帮忙的吗？”一个女性的售货员看到斯坦利有点茫然，问道。“这个小绅士穿多大的衣服啊？”他问斯坦利的妈妈——兰乔普女士。</p>
<p>“十号吧，我觉得，超薄的那种。”斯坦利的妈妈说。</p>
<p>“是特别场合穿的吗？”售货员又问。</p>
<p>“是的，我们要参加白金汉宫的一个舞会。”妈妈说。</p>
<p>“哇！这样啊！白金汉宫的舞会！那你们肯定是贵客！”售货员感叹道。</p>
<p>她找了好一会，终于找到一套斯坦利这个尺寸的西装：一条灰色的裤子，一件白色的衬衫，灰色的马甲和外套，外加一条黑色的领带。她还建议配一双黑色的皮鞋。</p>
<p>斯坦利费了好大劲把衬衫的扣子扣好，外套的袖子太长了。爸爸帮他系好领带。他穿好鞋子：鞋子太硬了，穿好这双鞋他好像都不会走路了。不过，当他穿好这一套衣服，站到镜子前面的时候，他不得不承认，他看起来就像个 VIP，完全可以去参加皇宫的舞会了。</p>
<p>与此同时，亚瑟却在旁边专心致志地看着橱窗里的玩具。售货员转头问兰乔普女士，“这个小帅哥也要一套吗？”</p>
<p>亚瑟立马回道，“噢不不不，不要了。”</p>
<p>“没门！如果我穿的话，你必须也得穿！”斯坦利把弟弟从玩具橱窗那边拽了过来。一切妥当之后，两兄弟都有了一套西装，还特别配。他们两个并排站在镜子前，亚瑟说，“我们看起来就像是双胞胎！”斯坦利想，不同点是一个扁，一个不扁。</p>
<p>妈妈笑了，她对两兄弟说，“你们换好自己原来的衣服，我们就去喝茶。哈罗德百货的优雅茶室最有名了！”</p>
<p>斯坦利和亚瑟换好了衣服。几分钟以后，他们一家人提着购物袋来到了一个美丽的茶室。他们一坐下，一个服务员就走了过来，问了他们一个贝茨警长问过的那个有趣的问题：“你们要喝一点点茶么？”</p>
<p>原来，在英国，那个问题的意思就是“你们要喝茶吗？”斯坦利不想“喝”茶，他想“吃”茶：因为在英国，下午茶就代表着好多各式各样的点心！斯坦利的爸爸妈妈给每个人倒了一杯冒着热气的茶，与此同时，两兄弟自顾自地吃起了各种各样的点心。</p>
<p>亚瑟拿起一个很小的三明治咬了一口，“黄瓜也能做三明治？从来没听说过，但是味道还不错。”</p>
<p>斯坦利切开一块热腾腾的司康饼（注 2），抹了厚厚的一层果酱，迫不及待地咬了一口，“嗯，好吃！”一些果酱挤到了他的手指上，他伸出舌头“咝溜”一下就舔干净了。</p>
<blockquote>
<p>注 2：司康饼 (scone)， 是英式快速面包 (Quick Bread) 的一种，它的名字是由苏格兰皇室加冕的地方，一块有长久历史并被称为司康之石 (Stone of Scone) 或命运之石 (Stone of Destiny) 的石头而来的。在全世界各地的早餐店、高级酒店自助吧里面都会提供，是西方世界的代表点心之一。</p>
</blockquote>
<p>舔完他紧张地看了妈妈一眼，妈妈没注意到他。他不礼貌的行为第一次逃过了妈妈的法眼。</p>
<p>不过，另外一个人注意到了他：坐在他们旁边一桌的女士。这位女士坐得笔直，当他看到斯坦利舔掉自己手指上的果酱的时候，她拿起放在大腿上的餐巾轻轻地擦了擦嘴。擦完看了看斯坦利，向斯坦利点了点头。她是在给我传递信息么？是在提醒我使用餐巾么？斯坦利想。</p>
<p>坐在那位女士对面的一个斯坦利这个年纪的小女孩。小女孩拿起桌上的刀叉，突然女士说话了，“露西，不对。你拿刀叉的方式不对。”说完，她抿了抿嘴。然后她拿起自己的刀叉，向露西演示了正确地使用刀叉的方法。</p>
<p>但是本该看着演示好好学习的露西却在看着斯坦利。她眼睛瞪得大大的，难以置信地捂住了自己的嘴。小女孩指着斯坦利喊道，“阿姨，你看！那是‘卡片男孩’斯……！”</p>
<p>那位女士没等她说完就把参扔在了桌子上。她声音不大，但是他说的话跟他抿着的嘴一样严格：“不可以用手指指着别人，露西。太不礼貌了。你要注意礼貌！我们今天就到这里吧。”</p>
<p>说完，他们两个人就快速走出了茶室。</p>
<p>看着他们两个走出了茶室，斯坦利皱了皱眉头，对他们一家人说，“那也太严格了吧？”</p>
<p>斯坦利的妈妈抿了一口茶，说，“良好的礼貌和习惯是英国的传统。那位阿姨只是在教会露西这些道理。你们也要了解一点，无论是喝茶还是参加皇室的舞会，都要保持良好的习惯，注意礼貌。”</p>
<p>斯坦利叹了一口气，他有点为露西感到难过。同时，也为自己感到难过。礼貌不是他的特长。但是，如果在英国注意礼貌是一个传统的话，他这次在皇宫执行任务也得注意了。只有遵循这一传统，他才能保证另一个传统——新国王加冕的王冠上一个珠宝都不能少。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://yiti.ml/fy011/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Dali Khan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Khan's Lab">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/fy011/" class="post-title-link" itemprop="url">不要视图，只要控制器，成不？</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-06-25 12:05" itemprop="dateCreated datePublished" datetime="2018-06-25T12:05:50+08:00">2018-06-25</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/translate/" itemprop="url" rel="index">
                    <span itemprop="name">翻译</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本文为 <a href="https://swift.gg/" target="_blank" rel="noopener">SwiftGG 项目组</a> 翻译文章，<a href="http://khanlou.com/2018/02/just-controllers/" target="_blank" rel="noopener">原文链接在此 </a>。<br> 原作者：Soroush Khanlou<br>原标题：Just Controllers<br>翻译：<em>PlayerUnkown</em><br>译文版权归译者所有，商业转载请联系 <a href="dearbojack.github.io"> 译者</a>。</p>
<hr>
<p>苹果官方文档中提到了 MVC 的软件设计模式。不过，苹果介绍的并不是本质意义上的 MVC 。<a href="http://khanlou.com/2014/03/model-view-whatever/" target="_blank" rel="noopener">关于这一点我之前也有写过一篇文章</a>，MVC 是为 Smalltalk 语言设计的一种设计模式。在 Smalltalk 语言里，MVC 的三个组件：模型（model）、视图（view）和控制器（controller）之间都可以相互通信。这就意味着或者视图知道如何实现一个模型，或者模型知道如何在视图中应用自己。</p>
<p>我们写 iOS 软件的时候，通常会把可以直接通信的视图和模型称之为“反模式”，不推荐这么做。我们所谓的 MVC 更准确的说其实是“模型 - 视图 - 适配器（Model - View - Adapter）”。我们说的“视图控制器”（适配器）其实只是模型和视图中间沟通的一个桥梁。笼统来讲，我觉得这是对正统 MVC 一个不错的改良——不是把视图和模型绑在一起，而是通过一个适配器把模型和视图联系起来，这个方法不错。然而，我不得不说，在我工作中涉及到的很多系统里，其实模型和视图都是分开的。</p>
<p>以上就是为什么 iOS 开发里会有视图控制器的原因：把模型和视图联系起来。但是这种模式的编码会产生一些问题：有一些代码看起来既不属于模型，也不属于视图，所以我们就把这些代码放到了视图控制器里，最后视图控制器变得超级臃肿。关于这个问题，我在博客里面讨论过 <a href="http://khanlou.com/2015/10/coordinators-redux/" target="_blank" rel="noopener"> 很多次</a>，但这次我想说的不是这个问题。</p>
<hr>
<p>我私下里听到过很多关于 <code>UIViewController</code> 的谈论。我认为 <code>UIViewController</code> 这个基本类写的不是很好，这个你用 UIKit 用得越久就越能感觉到。我听说 <code>UIViewController</code> 这个基本类型有 1 万到 2 万行代码（那是几年前了，现在可能已经超过两万行了）。</p>
<p>当我们需要把 <code>UIView</code> 和一个模型联系起来的时候，我们通常会把视图控制器分成一个个小的 视图控制器组件，然后再组装到一起。</p>
<p>但是，这样做太大动干戈（小题大做）了。一个小地方没处理好，就会出现很多 bug，而且这样的 bug 很难修复，也没有什么提示。然后，当你终于找到 bug 的时候，bug 通常是对 <code>didMove</code> 或者 <code>willMove</code> 调用的顺序不对，程序忽然就好了。其实，出现了 <code>didMove</code> 和<code>willMove</code>已经说明这些组件一些内部状态需要清理了。</p>
<p>这样的情况我自己就遇到过两次。第一次是我把视图控制器放在了 <code>tableView</code> 的<code>cell</code>里。出现的 bug 就是，table view 里面的一些内容总会莫名其妙地消失。然后过了好几个月，我才意识到我对 table view cells 的生命周期理解有误。</p>
<p>在我改正了一些对 <code>-addChildViewController</code> 的调用之后，程序就正常运行了。</p>
<p>这件事让我看到了一个很大的问题：视图控制器的视图并不是一个普普通通的视图。它知道自己不是一个普通的视图，而是一个视图控制器的视图，它有自己一些特性。</p>
<p>回过头去看，一切都很明显。<code>UIViewController</code>怎么知道什么时候该去调用 <code>viewDidLayoutSubviews</code>? 肯定是<code>view</code> 向它发送了请求，这就意味着视图对视图控制器是有一些了解的。</p>
<p>第二次是最近碰到的，这次我是在把一个视图控制器的视图作为一个 text field 的 <code>inputAccessoryView</code>。我是在实现一个通信软件（类似 iMessage）里<code>textField</code> 贴在屏幕底部的功能，整个过程十分挫败。我花了整整一天时间都没搞定，最后还是把这个视图转换成了一个普通的视图。</p>
<hr>
<p>所以，我们通常想让 <code>UIViewController1</code> 做的是哪些事情呢？</p>
<ul>
<li>承载视图</li>
<li>把模型和视图联系起来</li>
</ul>
<p>那 <code>UIViewController1</code> 还做了那些我们并不十分在意的事呢？</p>
<ul>
<li>为子视图控制器提供存储</li>
<li>把外观和过渡动画推送给子视图控制器</li>
<li>可以在类似 <code>UINavigationController</code> 的容器中显示</li>
<li>内存过低通知</li>
<li>处理状态栏</li>
<li>保存状态、恢复状态</li>
</ul>
<p>知道了这些，在一些特殊情况下，我们要做一个替代视图控制器的东西的时候，我们就知道了哪些东西是我们并不需要的。我喜欢这样，因为这样可以快速地解决问题，同时也符合我“自己的事情自己做”的性格。</p>
<p>还有一个问题，这个东西怎么命名呢？我觉得命名成一个视图控制器不太好，很容易被误解为一个 <code>UIViewController</code> 的子类。或者，我们就叫它 <code>Controller</code>? 我觉得可以（<a href="http://khanlou.com/2014/11/a-controller-by-any-other-name/" target="_blank" rel="noopener"> 尽管我之前可能有其他观点</a>），因为它的作用就是 iOS MVC 设计框架中控制器的作用（把视图和模型联系起来），但是还有其他一些备选：<code>Binder</code>（粘合）, <code>Binding</code>（捆绑）, <code>Pair</code>（配对）, <code>Mediator</code>（中介）, <code>Concierge</code>（前台）。</p>
<p>这个做法还有一个好处是，<strong>特别好写</strong>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DestinationTextFieldController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> destination: <span class="type">Destination?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> delegate: <span class="type">DestinationTextFieldControllerDelegate?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> textField = <span class="type">UITextField</span>().configure(&#123;</span><br><span class="line">        $<span class="number">0</span>.autocorrectionType = .no</span><br><span class="line">        $<span class="number">0</span>.clearButtonMode = .always</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不用 <code>UIViewController</code> 的子类，写个这样的东西，可能会有人喊，“异教徒！烧死他！”但是，当 <code>UIViewController</code> 没有把自己该做的事情做好的时候，我们就应该抛弃它。</p>
<p>大家已将知道怎么给自己的新对象加新功能了。在我的这个例子中，控制器成了 <code>textField</code> 的代理，文字变化时发出事件（以及域元数据 domain metadta），同时提供更新视图（这个例子中是<code>textField</code>）的接口。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">DestinationTextFieldController</span> </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> isActive: <span class="type">Bool</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">self</span>.textField.isFirstResponder</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">func</span> <span class="title">update</span><span class="params">(with destination: Destination)</span></span> &#123;</span><br><span class="line">		<span class="keyword">self</span>.destination = destination</span><br><span class="line">		configureView()</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">configureView</span><span class="params">()</span></span> &#123;</span><br><span class="line">		textField.text = destination.descriptionForDisplay</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用这种新的控制器你还需要做其他几件事：</p>
<ul>
<li>你得新建一个实例变量来存储数据</li>
<li>你得负责一些触发事件——因为它不是一个视图控制器，没有<code>-viewDidAppear</code></li>
<li>你不是在 <code>UIKit</code> 框架里面了，所以其他一些 <code>UIKit</code> 的特性（<a href="https://developer.apple.com/documentation/uikit/uitraitcollection" target="_blank" rel="noopener">UITraitCollection</a>, <a href="https://developer.apple.com/documentation/uikit/uiview/positioning_content_relative_to_the_safe_area" target="_blank" rel="noopener">safe area insets</a>, 或者<a href="https://developer.apple.com/documentation/uikit/uiresponder" target="_blank" rel="noopener">UIResponder</a>）你都不能再使用了。如果要使用，你必须自己实现。</li>
</ul>
<p>使用这个对象不是很难，不过你还是需要写明它的数据存储方式， 防止它的内存被回收。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyViewController</span>: <span class="title">UIViewController</span>, <span class="title">DestinationTextFieldControllerDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">let</span> destinationViewController = <span class="type">DestinationTextFieldController</span>()</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">		destinationViewController.delegate = <span class="keyword">self</span></span><br><span class="line">		view.addSubview(destinationViewController.view)</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//handle any delegate methods</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>话说回来，即使你使用我说的这个方法，其他大部分的视图应该还会是视图控制器和 <code>UIViewController</code> 的子类。不过，在某些特殊的情况下，整合一个视图控制器会耗费你过多的精力，这时候采用这种方法，就可以避免再次被 <code>UIKit</code> 折磨。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://yiti.ml/fy042/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Dali Khan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Khan's Lab">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/fy042/" class="post-title-link" itemprop="url">Swift 4 中的字符串</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-06-25 12:00" itemprop="dateCreated datePublished" datetime="2018-06-25T12:00:02+08:00">2018-06-25</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/translate/" itemprop="url" rel="index">
                    <span itemprop="name">翻译</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>本文为 SwiftGG 项目组翻译文章，<a href="https://oleb.net/blog/2017/11/swift-4-strings/" target="_blank" rel="noopener">原文链接在此</a>。</p>
</blockquote>
<p>本系列其他文章：</p>
<ol>
<li><a href="https://oleb.net/blog/2014/07/swift-strings/" target="_blank" rel="noopener">Swift 1 中的字符串</a></li>
<li><a href="https://oleb.net/blog/2016/08/swift-3-strings/" target="_blank" rel="noopener">Swift 3 中的字符串</a></li>
<li>Swift 4 中的字符串（本文）</li>
</ol>
<p>本文节选自我们的新书《高级 Swift 编程》「字符串」这一章。《高级 Swift 编程》已根据 Swift 4 的新特性修订补充，新版现已上市。</p>
<hr>
<p>所有的现代编程语言都支持 Unicode 编码的字符串，但这通常只意味着它们的字符串可以存储 Unicode 编码的数据——并不意味着所有像获取字符串长度这样简单的操作都会得到「合情合理」的输出结果。</p>
<p>其实，大多数编程语言（以及这些语言中大部分字符串操作的代码）都在一定程度上对复杂的 Unicode 编码敬而远之。这会导致一些烦人的 bug。</p>
<p>Swift 对于字符串的实现为了支持 Unicode 做出了巨大的努力。Swift 中的 <a href="https://developer.apple.com/documentation/swift/string" target="_blank" rel="noopener"><code>String</code></a>（字符串）是一系列<a href="https://developer.apple.com/documentation/swift/character" target="_blank" rel="noopener"><code>Character</code></a> 值（字符）的集合。这里的 <code>Character</code> 指的就是人们看到的字母，无论这个字母是由多少个 Unicode 编码组成的。因此，所有对于 <code>Collection</code>（集合）的操作（比如<code>count</code> 或者<code>prefix(5)</code>）也同样是按照人们所理解的字母来操作的。</p>
<p>这样的设计在正确性上无可挑剔，但这是有代价的——人们对它不熟悉。如果你习惯了其他编程语言里字符串的整数索引，Swift 的设计会让你觉得笨重不堪。为什么 <code>str[999]</code> 不能获得字符串第一千个字符？为什么 <code>str[idx+1]</code> 不能获得下一个字符？为什么不能用类似 <code>&quot;a&quot;...&quot;z&quot;</code> 的方式遍历一个范围的<code>Character</code>（字符）？</p>
<p>同时，这样的设计对代码性能也有一定的影响：<code>String</code>不支持随意获取。换句话说，获得一个任意字符是无法简简单单用 O(1)的操作实现的——当字符宽度是个变量的时候，字符串只有查看过前面所有字符之后，才会知道第 n 个字符是什么。</p>
<p>在本章中，我们一起来详细讨论一下 Swift 中字符串的设计，以及一些获得功能和性能最优的技巧。不过，首先我们要先来学习一下 Unicode 编码的专业知识。</p>
<h2 id="Unicode：抛弃固定宽度"><a href="#Unicode：抛弃固定宽度" class="headerlink" title="Unicode：抛弃固定宽度"></a>Unicode：抛弃固定宽度 </h2><p> 本来事情很简单。<a href="https://en.wikipedia.org/wiki/ASCII" target="_blank" rel="noopener">ASCII 编码 </a> 的字符串用 0 到 127 之间的一系列整数表示。如果使用 8 比特的二进制数组合表示字符，甚至还多余一个比特！由于每个字符的长度固定，所以 ASCII 编码的字符串是可以随机获取的。</p>
<p>但是，如果不是英语而是其他国家的语言的话，其中的一些字符 ASCII 编码是不够的（其实即使是说英语的英国也有一个”£”符号）。这些语言中的特殊字符大多数都需要超过 7 比特的编码。在 <a href="https://en.wikipedia.org/wiki/ISO/IEC_8859" target="_blank" rel="noopener">ISO 8859</a> 标准中，就用多出来的那个比特定义了 16 种超出 ASCII 编码范围的编码，比如第一部分（ISO8859-1）包括了几种西欧语言的编码，第五部分包括了对西里尔字母语言的编码。</p>
<p>但这样的做法其实还有局限。如果你想根据 ISO8859 标准，用土耳其语写古希腊语的话，你就不走运了，因为你要么得选择第七部分（拉丁语 / 希腊语）或者第九部分（土耳其语）。而且，总的说，八个比特的空间无法编码很多种语言。例如，第六部分（拉丁语 / 阿拉伯语）就不包含同样使用阿拉伯字母的乌尔都语和波斯语中的很多字符。同时，越南语虽然使用的也是拉丁字母，但是有很多变音组合，这种情况只有替换掉一些原有 ASCII 编码的字母（<strong>from the lower half??</strong>）才可能存储到 8 个比特的空间里。而且，对其他很多东亚语言来说，这种方法根本无效。</p>
<p>一个固定宽度的编码空间不够的时候，你要做一个选择：要么提高存储空间，要么转换成宽度可变的编码。起先，<a href="https://en.wikipedia.org/wiki/Unicode" target="_blank" rel="noopener">Unicode</a>被定义为 2 字节固定宽度的格式，现在我们称之为<a href="https://en.wikipedia.org/wiki/Universal_Coded_Character_Set" target="_blank" rel="noopener">UCS-2</a>。彼时梦想尚未照进现实，后来人们发现，要实现大部分的功能，不仅 2 字节不够，甚至 4 个字节都远远不够。</p>
<p>所以到了今天，Unicode 编码的宽度是可变的，这种可变有两个不同的含义：一是说 Unicode scalars 可能由若干个代码块组成；一是说字符可能由若干个 scalars 组成。</p>
<p>Unicode 编码的数据可以用多种不同宽度的 <a href="https://www.unicode.org/glossary/#code_unit" target="_blank" rel="noopener"> 代码块（<em>code unit</em>）</a>来表示，最常见的是 8 比特（<a href="https://en.wikipedia.org/wiki/UTF-8" target="_blank" rel="noopener">UTF-8</a>）和 16（<a href="https://en.wikipedia.org/wiki/UTF-16" target="_blank" rel="noopener">UTF-16</a>）比特。UTF-8 编码的一大优势是它向后兼容 8 比特的 ACSCII 编码，这也是它取代 ASCII 成为互联网上最受欢迎的编码的一大原因。在 Swift 里面用 <code>UInt16</code> 和<code>UInt8</code>的数值代表 UTC-16 和 UTF-8 的代码块（别名分别是 <a href="https://developer.apple.com/documentation/swift/unicode.utf8/codeunit" target="_blank" rel="noopener"><code>Unicode.UTF16.CodeUnit</code></a> 和<a href="https://developer.apple.com/documentation/swift/unicode.utf16/codeunit" target="_blank" rel="noopener"><code>Unicode.UTF8.CodeUnit</code></a>）。</p>
<p>一个 <a href="https://www.unicode.org/glossary/#code_point" target="_blank" rel="noopener"><em> 代码点（code point）</em></a>指的是 Unicode 编码空间中一个单一的值，可能的范围是 <code>0</code> 到<code>0x10FFFF</code>(换算成十进制就是 1114111)。现在已使用的代码点只有大约 137000 个，所以还有很多空间可以存储各种 emoji。如果你使用的是 <a href="https://en.wikipedia.org/wiki/UTF-32" target="_blank" rel="noopener">UTF-32</a> 编码，那么一个代码点就是一个代码块；如果使用的是 UTF-8 编码，一个代码点可能有 1 到 4 个代码块组成。最初的 256 个 Unicode 编码的代码点对应着 Latin-1 中的字母。</p>
<p><a href="https://www.unicode.org/glossary/#unicode_scalar_value" target="_blank" rel="noopener">Unicode scalars</a>跟代码点基本一样，但是也有一点不一样。除开 <code>0xD800-0xDFFF</code> 中间的 2048 个代理代码点（<a href="https://en.wikipedia.org/wiki/UTF-16#U.2BD800_to_U.2BDFFF" target="_blank" rel="noopener"><em>surrogate code points</em></a>）之外，他们都是一样的。这 2048 个代理代码点是 UTF-16 中用作表示配对的前缀或尾缀编码。Scalars 在 Swift 中用 <code>\u{xxxx}</code> 表示，xxxx 代表十进制的数字。所以欧元符号在 Swift 里可以表示为 <code>&quot;€&quot;</code> 或<code>&quot;\u{20AC}&quot;</code>。与之对应的 Swift 类型是 <a href="https://developer.apple.com/documentation/swift/unicode.scalar" target="_blank" rel="noopener"><code>Unicode.Scalar</code></a>，一个<a href="https://developer.apple.com/documentation/swift/uint32" target="_blank" rel="noopener"><code>UInt32</code></a> 数值的封装。</p>
<p>为了用一个代码块代表一个 Unicode scalar，你需要一个 21 比特的编码机制（通常会达到 32 比特，比如 UTF-32），但是即便这样你也无法得到一个固定宽度的编码：最终表示字符的时候，Unicode 仍然是一个宽度可变的编码格式。屏幕上显示的一个字符，也就是用户通常认为的一个字符，可能需要多个 scalar 组合而成。Unicode 编码里把这种用户理解的字符称之为<a href="https://www.unicode.org/glossary/#extended_grapheme_cluster" target="_blank" rel="noopener">（扩展）字素集</a>(extended grapheme cluster)。</p>
<p>Scalar 组成字素集的规则决定了如何分词。例如，如果你按了一下键盘上的退格键，你觉得你的文本编辑器就应该删除掉一个字素集，即使那个“字符”是由多个 Unicode scalars 组成，且每个 scalar 在计算机内存上还由数量不等的代码块组成的。Swift 中用 <code>Character</code> 类型代表字素集。<code>Character</code>类型可以由任意数量的 Scalars 组成，只要它们形成一个用户看到的字符。在下一部分，我们会看到几个这样的例子。</p>
<h2 id="字素集和规范对等（Canonical-Equivalence）"><a href="# 字素集和规范对等（Canonical-Equivalence）" class="headerlink" title="字素集和规范对等（Canonical Equivalence）"></a>字素集和规范对等（Canonical Equivalence）</h2><h3 id="组合符号"><a href="# 组合符号" class="headerlink" title="组合符号"></a>组合符号 </h3><p> 这里有一个快速了解 <code>String</code> 类型如何处理 Unicode 编码数据的方法：写“é”的两种不同方法。Unicode 编码中定义为 <a href="https://codepoints.net/U+00E9" target="_blank" rel="noopener">U+00E9</a>， <em>Latin small letter e with acute（拉丁字母小写 e 加重音符号），</em> 单一值。但是你也可以写一个正常的 <a href="https://codepoints.net/U+0065" target="_blank" rel="noopener"> 小写 e</a>，再跟上一个 <a href="https://codepoints.net/U+0301" target="_blank" rel="noopener">U+0301</a>，<em>combining acute accent</em>（重音符号）。在这两种情况中，显示的都是é，用户当然会认为这两个“résumé”无论使用什么方式打出来的，肯定是相等的，长度也都是 6 个字符。这就是 Unicode 编码规范中所说的<a href="https://www.unicode.org/glossary/#canonical_equivalent" target="_blank" rel="noopener"> 规范对等（Canonically Equivalent）</a>。</p>
<p>而且，在 Swift 语言里，代码行为和用户预期是一致的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> single = <span class="string">"Pok\u&#123;00E9&#125;mon"</span></span><br><span class="line"><span class="keyword">let</span> double = <span class="string">"Poke\u&#123;0301&#125;mon"</span></span><br></pre></td></tr></table></figure>

<p>它们显示也是完全一致的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(single, double) <span class="comment">// → ("Pokémon", "Pokémon")</span></span><br></pre></td></tr></table></figure>

<p>它们的字符数也是一样的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">single.<span class="built_in">count</span> <span class="comment">// → 7</span></span><br><span class="line">double.<span class="built_in">count</span> <span class="comment">// → 7</span></span><br></pre></td></tr></table></figure>

<p>因此，比较起来，它们也是相等的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">single == double <span class="comment">// → true</span></span><br></pre></td></tr></table></figure>

<p>只有当你通过底层的显示方式查看的时候，才能看到它们的不同之处：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">single.utf16.<span class="built_in">count</span> <span class="comment">// → 7</span></span><br><span class="line">double.utf16.<span class="built_in">count</span> <span class="comment">// → 8</span></span><br></pre></td></tr></table></figure>

<p>这一点和 Foundation 中的 <a href="https://developer.apple.com/documentation/foundation/nsstring" target="_blank" rel="noopener"><code>NSString</code></a> 对比一下：在 <code>NSString</code> 中，两个字符串是不相等的，它们的<code>length</code>（很多程序员都用这个方法来确定字符串显示在屏幕上的长度）也是不同的。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> nssingle = single <span class="keyword">as</span> <span class="type">NSString</span></span><br><span class="line">nssingle.length <span class="comment">// → 7</span></span><br><span class="line"><span class="keyword">let</span> nsdouble = double <span class="keyword">as</span> <span class="type">NSString</span></span><br><span class="line">nsdouble.length <span class="comment">// → 8</span></span><br><span class="line">nssingle == nsdouble <span class="comment">// → false</span></span><br></pre></td></tr></table></figure>

<p>这里，<code>==</code>是定义为比较两个<code>NSObject</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">extension NSObject: Equatable &#123;</span><br><span class="line">    static func &#x3D;&#x3D;(lhs: NSObject, rhs: NSObject) -&gt; Bool &#123;</span><br><span class="line">        return lhs.isEqual(rhs)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>NSString</code> 中，这个操作会比较两个 UTF-16 代码块。很多其他语言里面的字符串 API 也是这样的。如果你想做的是一个规范比较（cannonical comparison），你必须用<code>NSString.compare(_:)</code>。没听说过这个方法？将来遇到一些找不出来的 bug ，以及一些怒气冲冲的国外用户的时候，够你受的。</p>
<p>当然，只比较代码块有一个很大的优点是：速度快！在 Swift 里，你也可以通过 <code>utf16</code> 视图来实现这一点：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">single.utf16.elementsEqual(double.utf16) <span class="comment">// → false</span></span><br></pre></td></tr></table></figure>

<p>为什么 Unicode 编码要支持同一字符的多种展现方式呢？</p>
<blockquote>
<p>因为 Latin-1 中已经有了类似é和ñ这样的字母，只有灵活的组合方式才能让长度可变的 Unicode 代码点兼容 Latin-1。</p>
<p>The existence of precomposed characters is what enables the opening range of Unicode code points to be compatible with Latin-1, which already had characters like é and ñ.</p>
</blockquote>
<p>虽然使用起来会有一些麻烦，但是它使得两种编码之间的转换变得简单快速。</p>
<p>而且抛弃变音形式也没有什么用，因为这种组合不仅仅只是两个两个的，有时候甚至是多种变音组合。例如，约鲁巴语中有一个字符是 ọ́ ，可以用三种不同方式写出来：一个 ó加一点，一个 ọ加一个重音，或者一个 o 加一个重音和一点。而且，对最后一种方式来说，两个变音的顺序无关紧要！所以，下面几种形式的写法都是相等的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> chars: [<span class="type">Character</span>] = [</span><br><span class="line">    <span class="string">"\u&#123;1ECD&#125;\u&#123;300&#125;"</span>,      <span class="comment">// ọ́</span></span><br><span class="line">    <span class="string">"\u&#123;F2&#125;\u&#123;323&#125;"</span>,        <span class="comment">// ọ́</span></span><br><span class="line">    <span class="string">"\u&#123;6F&#125;\u&#123;323&#125;\u&#123;300&#125;"</span>, <span class="comment">// ọ́</span></span><br><span class="line">    <span class="string">"\u&#123;6F&#125;\u&#123;300&#125;\u&#123;323&#125;"</span>  <span class="comment">// ọ́</span></span><br><span class="line">]</span><br><span class="line"><span class="keyword">let</span> allEqual = chars.<span class="built_in">dropFirst</span>()</span><br><span class="line">    .all(matching: &#123; $<span class="number">0</span> == chars.first &#125;) <span class="comment">// → true</span></span><br></pre></td></tr></table></figure>

<p><code>all(matching:)</code>方法用来检测条件是否对所有序列中的元素都为真：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Sequence</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">all</span><span class="params">(matching predicate: <span class="params">(Element)</span></span></span> <span class="keyword">throws</span> -&gt; <span class="type">Bool</span>) <span class="keyword">rethrows</span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> element <span class="keyword">in</span> <span class="keyword">self</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">try</span> !predicate(element) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实，一些变音元素可以加无穷个。这一点，<a href="http://knowyourmeme.com/memes/zalgo" target="_blank" rel="noopener">网上流传很广 </a> 的一个颜文字表现得很好：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> zalgo = <span class="string">"s̼̐͗͜o̠̦̤ͯͥ̒ͫ́ͅo̺̪͖̗̽ͩ̃͟ͅn̢͔͖͇͇͉̫̰ͪ͑"</span></span><br><span class="line"></span><br><span class="line">zalgo.<span class="built_in">count</span> <span class="comment">// → 4</span></span><br><span class="line">zalgo.utf16.<span class="built_in">count</span> <span class="comment">// → 36</span></span><br></pre></td></tr></table></figure>

<p>上面的例子中，<code>zalgo.count</code>返回值是 4（正确的），而 <code>zalgo.utf16.count</code> 返回值是 36。如果你的代码连网上的颜文字都无法正确处理，要它何用？？</p>
<p>Unicode 编码的字素分割规则甚至在你处理纯 ASCII 编码的字符的时候也有影响，回车 <a href="https://codepoints.net/U+000D" target="_blank" rel="noopener">CR</a> 和换行 <a href="https://codepoints.net/U+000A" target="_blank" rel="noopener">LF</a> 这一个字符对在 Windows 系统上通常表示新开一行，但它们其实只是一个字素：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CR+LF is a single Character</span></span><br><span class="line"><span class="keyword">let</span> crlf = <span class="string">"\r\n"</span></span><br><span class="line">crlf.<span class="built_in">count</span> <span class="comment">// → 1</span></span><br></pre></td></tr></table></figure>

<h3 id="Emoji"><a href="#Emoji" class="headerlink" title="Emoji"></a>Emoji</h3><p>许多其他编程语言处理包含 emoji 的字符串的时候会让人意外。许多 emoji 的 Unicode scalar 无法存储在一个 UTF-16 的代码块里面。有些语言（例如 Java 或者 C#）把字符串当做 UTF-16 代码块的集合，这些语言定义 <a href="https://emojipedia.org/face-with-tears-of-joy/" target="_blank" rel="noopener">“😂”</a> 为两个“字符”的长度。Swift 也是这么处理的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> oneEmoji = <span class="string">"😂"</span> <span class="comment">// U+1F602</span></span><br><span class="line">oneEmoji.<span class="built_in">count</span> <span class="comment">// → 1</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，重要的是字符串是如何展现给程序的，<strong>不是 </strong> 字符串在内存中是如何存储的。对于非 ASCII 的字符串，Swift 内部用的是 UTF-16 的编码，这只是内部的实现细节。公共 API 还是基于字素集（grapheme cluster）的。</p>
</blockquote>
<p>有些 emoji 由多个 scalars 组成。emoji 中的国旗是由两个对应 ISO 国家代码的 <a href="https://en.wikipedia.org/wiki/Regional_Indicator_Symbol" target="_blank" rel="noopener"> 地区标识符号（reginal indicator symbols）</a>组成的。Swift 里将一个国旗视为一个<code>Character</code>:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> flags = <span class="string">"🇧🇷🇳🇿"</span></span><br><span class="line">flags.<span class="built_in">count</span> <span class="comment">// → 2</span></span><br></pre></td></tr></table></figure>

<p>要检查一个字符串由几个 Unicode scalars 组成，需要使用 <a href="https://developer.apple.com/documentation/swift/string/1539070-unicodescalars" target="_blank" rel="noopener"><code>unicodeScalars</code></a> 视图。这里，我们将 scalar 的值格式化为十进制的数字，这是代码点的普遍格式：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">flags.unicodeScalars.<span class="built_in">map</span> &#123;</span><br><span class="line">    <span class="string">"U+\(String($0.value, radix: 16, uppercase: true))"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// → ["U+1F1E7", "U+1F1F7", "U+1F1F3", "U+1F1FF"]</span></span><br></pre></td></tr></table></figure>

<p>肤色是由一个基础的角色符号（ 例如👧）加上一个肤色修饰符（例如🏽）组成的，Swift 里是这么处理的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> skinTone = <span class="string">"👧🏽"</span> <span class="comment">// 👧 + 🏽</span></span><br><span class="line">skinTone.<span class="built_in">count</span> <span class="comment">// → 1</span></span><br></pre></td></tr></table></figure>

<p>这次我们用 Foundation API 里面的 <a href="https://oleb.net/blog/2016/01/icu-text-transforms/" target="_blank" rel="noopener">ICU string transform</a> 把 Unicode scalars 转换成官方的 Unicode 名称：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">StringTransform</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> toUnicodeName = <span class="type">StringTransform</span>(rawValue: <span class="string">"Any-Name"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Unicode</span>.<span class="title">Scalar</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// The scalar’s Unicode name, e.g. "LATIN CAPITAL LETTER A".</span></span><br><span class="line">    <span class="keyword">var</span> unicodeName: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="comment">// Force-unwrapping is safe because this transform always succeeds</span></span><br><span class="line">        <span class="keyword">let</span> name = <span class="type">String</span>(<span class="keyword">self</span>).applyingTransform(.toUnicodeName,</span><br><span class="line">            <span class="built_in">reverse</span>: <span class="literal">false</span>)!</span><br><span class="line"></span><br><span class="line">        <span class="comment">// The string transform returns the name wrapped in "\\N&#123;...&#125;". Remove those.</span></span><br><span class="line">        <span class="keyword">let</span> prefixPattern = <span class="string">"\\N&#123;"</span></span><br><span class="line">        <span class="keyword">let</span> suffixPattern = <span class="string">"&#125;"</span></span><br><span class="line">        <span class="keyword">let</span> prefixLength = name.hasPrefix(prefixPattern) ? prefixPattern.<span class="built_in">count</span> : <span class="number">0</span></span><br><span class="line">        <span class="keyword">let</span> suffixLength = name.hasSuffix(suffixPattern) ? suffixPattern.<span class="built_in">count</span> : <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="type">String</span>(name.<span class="built_in">dropFirst</span>(prefixLength).<span class="built_in">dropLast</span>(suffixLength))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">skinTone.unicodeScalars.<span class="built_in">map</span> &#123; $<span class="number">0</span>.unicodeName &#125;</span><br><span class="line"><span class="comment">// → ["GIRL", "EMOJI MODIFIER FITZPATRICK TYPE-4"]</span></span><br></pre></td></tr></table></figure>

<p>这段代码里面最重要的是对 <code>applyingTransform(.toUnicodeName,...)</code> 的调用。其他的代码只是把转换方法返回的名字清理了一下，移除了括号。这段代码很保守：先是检查了字符串是否符合期望的格式，然后计算了从头到尾的字符数。如果将来转换方法返回的名字格式发生了变化，最好输出原字符串，而不是移除多余字符后的字符串。</p>
<p>注意我们是如何使用标准的集合（<code>Collection</code>）方法 <code>dropFirst</code> 和<code>droplast</code>进行移除操作的。如果你想对字符串进行操作，但是又不想对字符串进行手动索引，这就是一个很好的例子。这个方法同样也很高效，因为 <code>dropFisrt</code> 和<code>dropLast</code>方法返回的是 <code>Substring</code> 值，它们只是原字符串的一部分。在我们最后一步创建一个新的 <code>String</code> 字符串，赋值为这个 substring 之前，它是不占用新的内存的。关于这一点，我们在这一章的后面还有很多东西会涉及到。</p>
<p>Emoji 里面对家庭和夫妻的表示（例如<a href="https://emojipedia.org/family-man-woman-girl-boy/" target="_blank" rel="noopener">👨‍👩‍👧‍👦</a> 和 <a href="https://emojipedia.org/couple-with-heart-woman-woman/" target="_blank" rel="noopener">👩‍❤️‍👩</a> ）是 Unicode 编码标准面临的又一个挑战。由于性别以及人数的可能组合太多，为每种可能的组合都做一个代码点肯定会有问题。再加上每个人物角色的肤色的问题，这样做几乎不可行。Unicode 编码是这样解决这个问题的，它将这种 emoji 定义为一系列由零宽度连接符（<a href="https://codepoints.net/U+200D" target="_blank" rel="noopener"><em>zero-width joiner</em></a>）联系起来的 emoji 。这样下来，这个家庭👨‍👩‍👧‍👦 emoji 其实就是 <a href="https://emojipedia.org/man/" target="_blank" rel="noopener"><em>man</em> 👨</a> + ZWJ + <a href="https://emojipedia.org/woman/" target="_blank" rel="noopener"><em>woman</em> 👩</a> + ZWJ + <a href="https://emojipedia.org/girl/" target="_blank" rel="noopener"><em>girl</em>👧</a> + ZWJ + <a href="https://emojipedia.org/boy/" target="_blank" rel="noopener"><em>boy</em> 👦</a>。而零宽度连接符的作用就是让操作系统知道这个 emoji 应该只是一个字素。</p>
<p>我们可以验证一下到底是不是这样：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> family1 = <span class="string">"👨‍👩‍👧‍👦"</span></span><br><span class="line"><span class="keyword">let</span> family2 = <span class="string">"👨\u&#123;200D&#125;👩\u&#123;200D&#125;👧\u&#123;200D&#125;👦"</span></span><br><span class="line">family1 == family2 <span class="comment">// → true</span></span><br></pre></td></tr></table></figure>

<p>在 Swift 里，这样一个 emoji 也同样被认为是一个字符<code>Character</code>:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">family1.<span class="built_in">count</span> <span class="comment">// → 1</span></span><br><span class="line">family2.<span class="built_in">count</span> <span class="comment">// → 1</span></span><br></pre></td></tr></table></figure>

<p>2016 年新引入的职业类型 emoji 也是这种情况。例如女性消防队员<a href="https://emojipedia.org/female-firefighter/" target="_blank" rel="noopener">👩‍🚒</a> 就是 <a href="https://emojipedia.org/woman/" target="_blank" rel="noopener"><em>woman</em> 👩</a> + ZWJ + <a href="https://emojipedia.org/fire-engine/" target="_blank" rel="noopener"><em>fire engine</em> 🚒</a>。男性医生就是<a href="https://emojipedia.org/man/" target="_blank" rel="noopener"><em>man</em> 👨</a> + ZWJ + <a href="https://emojipedia.org/staff-of-aesculapius/" target="_blank" rel="noopener"><em>staff of aesculapius</em> ⚕</a>（译者注：阿斯克勒庇厄斯，是古希腊神话中的医神，一条蛇绕着一个柱子指医疗相关职业）。</p>
<p>将这些一系列零宽度连接符连接起来的 emoji 渲染为一个字素是操作系统的工作。2017 年，Apple 的操作系统表示支持 Unicode 编码标准下的 RGI 系列（“<a href="https://unicode.org/emoji/charts/emoji-zwj-sequences.html" target="_blank" rel="noopener">recommended for general interchange</a>”）。如果没有字素可以正确表示这个序列，那文本渲染系统会回退，显示为每个单个的字素。</p>
<p>注意这里又可能会导致一个理解偏差，即用户所认为的字符和 Swift 所认为的字素集之间的偏差。我们上面所有的例子都是担心编程语言会把字符 <strong> 数多了</strong>，但这里正好相反。举例来说，上面那个家庭的 emoji 里面涉及到的肤色 emoji 还未被收录到 RGI 集合里面。但尽管大多数操作系统都把这系列 emoji 渲染成多个字素，但 Swift 仍旧只把它们看做一个字符，因为 Unicode 编码的分词规则和渲染无关：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Family with skin tones is rendered as multiple glyphs</span></span><br><span class="line"><span class="comment">// on most platforms in 2017</span></span><br><span class="line"><span class="keyword">let</span> family3 = <span class="string">"👱🏾\u&#123;200D&#125;👩🏽\u&#123;200D&#125;👧🏿\u&#123;200D&#125;👦🏻"</span> <span class="comment">// → "👱🏾‍👩🏽‍👧🏿‍👦🏻"</span></span><br><span class="line"><span class="comment">// But Swift still counts it as a single Character</span></span><br><span class="line">family3.<span class="built_in">count</span> <span class="comment">// → 1</span></span><br></pre></td></tr></table></figure>

<p><a href="https://blog.emojipedia.org/diverse-emoji-families-come-to-windows/" target="_blank" rel="noopener">Windows 系统已经可以 </a> 把这些 emoji 渲染为一个字素了，其他操作系统厂家肯定也会尽快支持。但是，有一点是不变的：无论一个字符串的 API 如何精心设计，都无法完美支持每一个细小的案例，因为文本太复杂了。</p>
<blockquote>
<p>过去 Swift 很难跟得上 Unicode 编码标准改变的步伐。Swift 3 渲染肤色和零宽度连接符系列 emoji 是错误的，因为当时的分词算法是根据上一个版本的 Unicode 编码标准。自 Swift 4 起，Swift 开始启用操作系统的 <a href="http://site.icu-project.org" target="_blank" rel="noopener">ICU</a>库。因此，只要用户更新他们的操作系统，你的程序就会采用最新的 Unicode 编码标准。硬币的另一面是，你开发中看到的和用户看到的东西可能是不一样的。</p>
</blockquote>
<p>编程语言如果不全盘考虑 Unicode 编码的复杂性的话，在处理文本的时候会出现很多问题。上面的这么多例子我们只是在谈其中的一个问题：字符串的长度。如果一个编程语言不是按字素集处理字符串，而这个字符串又包含很多字符序列的话，这时候一个简简单单的反序输出字符串的操作会变得多么复杂。</p>
<p>这不是个新问题，但是 emoji 的流行使得糟糕的文本处理方法造成的问题更容易浮出表面，即使你的用户群大部分是说英语的。而且，错误的级别也大大提升：十年前，弄错一个变音符号的字母可能只会造成 1 个字符数的误差，现在如果弄错了 emoji 的话很可能就是 10 个字符数的误差。例如，一个四人家庭的 emoji 在 UTF-16 编码下是 11 个字符，在 UTF-8 编码下就是 25 个字符了：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">family1.<span class="built_in">count</span> <span class="comment">// → 1</span></span><br><span class="line">family1.utf16.<span class="built_in">count</span> <span class="comment">// → 11</span></span><br><span class="line">family1.utf8.<span class="built_in">count</span> <span class="comment">// → 25</span></span><br></pre></td></tr></table></figure>

<p>也不是说其他编程语言就完全没有符合 Unicode 编码标准的 API，大部分还是有的。例如，<code>NSString</code>就有一个 <a href="https://developer.apple.com/documentation/foundation/nsstring/1416774-enumeratesubstrings" target="_blank" rel="noopener"><code>enumerateSubstrings</code></a> 的方法可以按照字素集遍历一个字符串。但是缺省设置很重要，而 Swift 的原则就是缺省情况下，就按正确的方式来做。而且如果你需要低一个抽象级别去看，<code>String</code>也提供不同的视图，然你可以直接从 Unicode scalar 或者代码块的级别操作。下面的内容里我们还会涉及到这一点。</p>
<h2 id="字符串和集合"><a href="# 字符串和集合" class="headerlink" title="字符串和集合"></a>字符串和集合 </h2><p> 我们已经看到，<code>String</code>是一个 <code>Character</code> 值的集合。在 Swift 语言发展的前三年里，<code>String</code>这个类在遵守还是不遵守 <code>Collection</code> 集合协议这个问题上左右摇摆了几次。坚持不要遵守集合协议的人认为，如果遵守的话，程序员会认为所有通用的集合处理算法用在字符串上是绝对安全的，也绝对符合 Unicode 编码标准的，但是显然有一些特例存在。</p>
<p>举一个简单的例子，两个集合相加，得到的新的集合的长度肯定是两个子集合长度的和。但是在字符串中，如果第一个字符串的后缀和第二个字符串的前缀形成了一个字素集，长度就会有变化了：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> flagLetterJ = <span class="string">"🇯"</span></span><br><span class="line"><span class="keyword">let</span> flagLetterP = <span class="string">"🇵"</span></span><br><span class="line"><span class="keyword">let</span> flag = flagLetterJ + flagLetterP <span class="comment">// → "🇯🇵"</span></span><br><span class="line">flag.<span class="built_in">count</span> <span class="comment">// → 1</span></span><br><span class="line">flag.<span class="built_in">count</span> == flagLetterJ.<span class="built_in">count</span> + flagLetterP.<span class="built_in">count</span> <span class="comment">// → false</span></span><br></pre></td></tr></table></figure>

<p>出于这种考虑，在 Swift 2 和 Swift 3 中，<code>String</code>并没有被算作一个集合。这个特性是作为 <code>String</code> 的一个 <a href="https://developer.apple.com/documentation/swift/string/1540072-characters" target="_blank" rel="noopener"><code>characters</code></a> 视图存在的，和其他几个集合视图一样：<a href="https://developer.apple.com/documentation/swift/string/1539070-unicodescalars" target="_blank" rel="noopener"><code>unicodeScalars</code></a>，<a href="https://developer.apple.com/documentation/swift/string/1539703-utf8" target="_blank" rel="noopener"><code>utf8</code></a> 和<a href="https://developer.apple.com/documentation/swift/string/1541301-utf16" target="_blank" rel="noopener"><code>utf16</code></a>。选择一个特定的视图，就相当于让程序员转换到另一种“处理集合”的模式，相应的，程序员就必须考虑到这种模式下可能产生的问题。</p>
<p>但是，在实际应用中，这个改变提升了学习成本，降低了可用性；单单为了保证在那些极端个例中的正确性（其实在真实应用中很少遇到，除非你写的是个文本编辑器的应用）做出这样的改变太不值得了。因此，在 Swift 4 中，<code>String</code>再次成了一个集合。<code>characters</code>视图还在，但是只是为了向后兼容 Swift 3。</p>
<h3 id="双向获取，而非任意获取"><a href="# 双向获取，而非任意获取" class="headerlink" title="双向获取，而非任意获取"></a>双向获取，而非任意获取 </h3><p> 然而，<code>String</code>并 <strong> 不是 </strong> 一个可以任意获取的集合，原因的话，上一部分的几个例子已经展现的很清楚。一个字符到底是第几个字符取决于它前面有多少个 Unicode scalar，这样的情况下，根本不可能实现任意获取。由于这个原因，Swift 里面的字符串遵守双向获取（<a href="https://developer.apple.com/documentation/swift/bidirectionalcollection" target="_blank" rel="noopener"><code>BidirectionalCollection</code></a>）规则。可以从字符串的两头数，代码会根据相邻字符的组成，跳过正确数量的字节。但是，每次访问只能上移或者下移一个字符。</p>
<p>在写处理字符串的代码的时候，要考虑到这种方式的操作对代码性能的影响。那些依靠任意获取来保证代码性能的算法对 Unicode 编码的字符串并不合适。我们看一个例子，我们要获取一个字符串所有 prefix 的列表。我们只需要得到一个从零到字符串长度的一系列整数，然后根据每个长度的整数在字符串中找到对应长度的 prefix ：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> allPrefixes1: [<span class="type">Substring</span>] &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">0</span>...<span class="keyword">self</span>.<span class="built_in">count</span>).<span class="built_in">map</span>(<span class="keyword">self</span>.<span class="keyword">prefix</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> hello = <span class="string">"Hello"</span></span><br><span class="line">hello.allPrefixes1 <span class="comment">// → ["","H","He","Hel","Hell","Hello"]</span></span><br></pre></td></tr></table></figure>

<p>尽管这段代码看起来很简单，但是运行性能很低。它先是遍历了字符串一次，计算出字符串的长度，这还 OK。但是每次对 <a href="https://developer.apple.com/documentation/swift/substring/2893985-prefix" target="_blank" rel="noopener"><code>prefix</code></a> 进行 n+1 的调用都是一次 <em>O(n)* 操作，因为<code>prefix</code> 方法需要从字符串的开头往后找出所需数量的字符。而在一个线性运算里进行另一个线性运算就意味着算法已经成了 *O(n2)</em> ——随着字符串长度的增加，算法所需的时间是呈指数级增长的。</p>
<p>如果可能的话，一个高性能的算法应该是遍历字符串一次，然后通过对字符串索引的操作得到想要的子字符串。下面是相同算法的另一个版本：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> allPrefixes2: [<span class="type">Substring</span>] &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="string">""</span>] + <span class="keyword">self</span>.<span class="built_in">indices</span>.<span class="built_in">map</span> &#123; index <span class="keyword">in</span> <span class="keyword">self</span>[...index] &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hello.allPrefixes2 <span class="comment">// → ["", "H", "He", "Hel", "Hell", "Hello"]</span></span><br></pre></td></tr></table></figure>

<p>这段代码只需要遍历字符串一次，得到字符串的索引（<a href="https://developer.apple.com/documentation/swift/bidirectionalcollection/1785188-indices" target="_blank" rel="noopener"><code>indices</code></a>）集合。一旦完成之后，之后再 <code>map</code> 内的操作就只是<em>O(1)</em>。整个算法也只是 <em>O(n)</em>。</p>
<h3 id="范围可替换，不可变"><a href="# 范围可替换，不可变" class="headerlink" title="范围可替换，不可变"></a>范围可替换，不可变 </h3><p><code>String</code> 还遵从于 <a href="https://developer.apple.com/documentation/swift/rangereplaceablecollection" target="_blank" rel="noopener"><code>RangeReplaceableCollection</code></a>（范围可替换）的集合操作。也就是说，你可以先按字符串索引的形式定义出一个范围，然后通过调用<a href="https://developer.apple.com/documentation/swift/string/1641462-replacesubrange" target="_blank" rel="noopener"><code>replaceSubrange</code></a>（替换子范围）方法，替换掉字符串中的一些字符。这里有一个例子。替换的字符串可以有不同的长度，甚至还可以是空的（这时候就相当于调用<a href="https://developer.apple.com/documentation/swift/string/2893740-removesubrange" target="_blank" rel="noopener"><code>removeSubrange</code></a> 方法了）：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> greeting = <span class="string">"Hello, world!"</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> comma = greeting.index(of: <span class="string">","</span>) &#123;</span><br><span class="line">    greeting[..&lt;comma] <span class="comment">// → "Hello"</span></span><br><span class="line">    greeting.replaceSubrange(comma..., with: <span class="string">"again."</span>)</span><br><span class="line">&#125;</span><br><span class="line">greeting <span class="comment">// → "Hello again."</span></span><br></pre></td></tr></table></figure>

<p>同样，这里也要注意一个问题，如果替换的字符串和原字符串中相邻的字符形成了新的字素集，那结果可能就会有点出人意料了。</p>
<p>字符串无法提供的一个类集合的特性是：<a href="https://developer.apple.com/documentation/swift/mutablecollection" target="_blank" rel="noopener"><code>MutableCollection</code></a>。该协议给集合除 <code>get</code> 之外，添加了一个通过下标进行单一元素 <code>set</code> 的特性。这并不是说字符串是不可变的——我们上面已经看到了，有好几种变化的方法。你无法完成的是使用下标操作符替换其中的一个字符。许多人直觉认为用下标操作符替换一个字符是即时发生的，就像数组 <a href="https://developer.apple.com/documentation/swift/array" target="_blank" rel="noopener"><code>Array</code></a>里面的替换一样。但是，因为字符串里的字符长度是不定的，所以替换一个字符的时间和字符串的长度呈线性关系：替换一个元素的宽度会把其他所有元素在内存中的位置重新洗牌。而且，替换元素索引后面的元素索引在洗牌之后都变了，这也是跟人们的直觉相违背的。出于这些原因，你必须使用 <code>replaceSubrange</code> 进行替换，即使你变化只是一个元素。</p>
<h2 id="字符串索引"><a href="# 字符串索引" class="headerlink" title="字符串索引"></a>字符串索引 </h2><p> 大多数编程语言都是用整数作为字符串的下标，例如 <code>str[5]</code> 就会返回 <code>str</code> 的第六个”字符“（无论这个语言定义的“字符”是什么）。Swift 却不允许这样。为什么呢？原因可能你已经听了很多遍了：下标应该是使用固定时间的(无论是直觉上，还是根据集合协议)，但是查询第 n 个“字符”的操作必须查询它前面所有的字节。</p>
<p><a href="https://developer.apple.com/documentation/swift/string.index" target="_blank" rel="noopener">字符串索引（<code>String.Index</code>）</a>是字符串及其视图使用的索引类型。它是个不透明值（opaque value，内部使用的值，开发者一般不直接使用），本质上存储的是从字符串开头算起的字节偏移量。如果你想计算第 n 个字符的索引，它还是一个 <em>O(n)</em> 的操作，而且你还是必须从字符串的开头开始算起，但是一旦你有了一个正确的索引之后，对这个字符串进行下标操作就只需要<em>O(1)</em> 次了。关键是，找到现有索引后面的元素的索引的操作也会变得很快，因为你只需要从已有索引字节后面开始算起了——没有必要从字符串开头开始了。这也是为什么有序（向前或是向后）访问字符串里的字符效率很高的原因。</p>
<p>字符串索引操作的依据跟你在其他集合里使用的所有 API 一样。因为我们最常用的集合——数组——使用的是整数索引，我们通常使用简单的算术来操作，所以有一点很容易忘记： <a href="https://developer.apple.com/documentation/swift/string/1782583-index" target="_blank" rel="noopener"><code>index(after:)</code></a> 方法返回的是下一个字符的索引：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">"abcdef"</span></span><br><span class="line"><span class="keyword">let</span> second = s.index(after: s.startIndex)</span><br><span class="line">s[second] <span class="comment">// → "b"</span></span><br></pre></td></tr></table></figure>

<p>使用 <a href="https://developer.apple.com/documentation/swift/string/1786175-index" target="_blank" rel="noopener"><code>index(_:offsetBy:)</code></a>方法，你可以通过一次操作，自动地访问多个字符，</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Advance 4 more characters</span></span><br><span class="line"><span class="keyword">let</span> sixth = s.index(second, offsetBy: <span class="number">4</span>)</span><br><span class="line">s[sixth] <span class="comment">// → "f"</span></span><br></pre></td></tr></table></figure>

<p>如果可能超出字符串末尾，你可以加一个 <a href="https://developer.apple.com/documentation/swift/anybidirectionalcollection/1781464-index" target="_blank" rel="noopener"><code>limitedBy:</code></a> 参数。如果在访问到目标索引之前到达了字符串的末尾，这个方法会返回一个 <code>nil</code> 值。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> safeIdx = s.index(s.startIndex, offsetBy: <span class="number">400</span>, limitedBy: s.endIndex)</span><br><span class="line">safeIdx <span class="comment">// → nil</span></span><br></pre></td></tr></table></figure>

<p>比起简单的整数索引，这无疑使用了更多的代码。<strong>这是 Swift 故意的。</strong>如果 Swift 允许对字符串进行整数索引，那不小心写出性能烂到爆的代码（比如在一个循环中使用整数的下标操作）的诱惑太大了。</p>
<p>然而，对一个习惯于处理固定宽度字符的人来说，刚开始使用 Swift 处理字符串会有些挑战——没有了整数索引怎么搞？而且确实，一些看起来简单的任务处理起来还得大动干戈，比如提取字符串的前四个字符：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s[..&lt;s.index(s.startIndex, offsetBy: <span class="number">4</span>)] <span class="comment">// → "abcd"</span></span><br></pre></td></tr></table></figure>

<p>不过谢天谢地，你可以使用集合的接口来获取字符串，这意味着许多适用于数组的方法同样也适用于字符串。比如上面那个例子，如果使用 <code>prefix</code> 方法就简单得多了：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.<span class="keyword">prefix</span>(<span class="number">4</span>) <span class="comment">// → "abcd"</span></span><br></pre></td></tr></table></figure>

<p>（注意，上面的几个方法返回的都是子字符串 <a href="https://developer.apple.com/documentation/swift/substring" target="_blank" rel="noopener"><code>Substring</code></a>，你可以使用一个 <code>String.init</code> 把它转换为字符串。关于这一部分，我们下一部分会讲更多。）</p>
<p>没有整数索引，循环访问字符串里的字符也很简单，用 <code>for</code> 循环。如果你想按顺序排列，使用 <a href="https://developer.apple.com/documentation/swift/sequence/1641222-enumerated" target="_blank" rel="noopener"><code>enumerated()</code></a>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i, <span class="built_in">c</span>) <span class="keyword">in</span> s.enumerated() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\(i): \(c)"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者如果你想找到一个特定的字符，你可以使用 <a href="https://developer.apple.com/documentation/swift/string/2893264-index" target="_blank" rel="noopener"><code>index(of:)</code></a>:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hello = <span class="string">"Hello!"</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> idx = hello.index(of: <span class="string">"!"</span>) &#123;</span><br><span class="line">    hello.insert(contentsOf: <span class="string">", world"</span>, at: idx)</span><br><span class="line">&#125;</span><br><span class="line">hello <span class="comment">// → "Hello, world!"</span></span><br></pre></td></tr></table></figure>

<p> <a href="https://developer.apple.com/documentation/swift/string/2893571-insert" target="_blank" rel="noopener"><code>insert(contentsOf:at:)</code></a> 方法可以在指定索引前插入相同类型的另一个集合（比如说字符串里的字符）。并不一定是另一个字符串，你可以很容易地把一个字符的数组插入到一个字符串里。</p>
<h2 id="子字符串"><a href="# 子字符串" class="headerlink" title="子字符串"></a>子字符串 </h2><p> 和其他的集合一样，字符串有一个特定的切片类型或者说子序列类型（ <a href="https://developer.apple.com/documentation/swift/collection/1641276-subsequence" target="_blank" rel="noopener"><code>SubSequence</code></a> ）：子字符串（ <a href="https://developer.apple.com/documentation/swift/substring" target="_blank" rel="noopener"><code>Substring</code></a>）。子字符串就像是一个数组切片（ <a href="https://developer.apple.com/documentation/swift/arrayslice" target="_blank" rel="noopener"><code>ArraySlice</code></a>）：它是原字符串的一个视图，起始索引和结束索引不同。子字符串共享原字符串的文本存储空间。这是一个很大的优势，对一个字符串进行切片操作不占用内存空间。在下面的例子中，创建 <code>firstWord</code> 变量不占用内存：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sentence = <span class="string">"The quick brown fox jumped over the lazy dog."</span></span><br><span class="line"><span class="keyword">let</span> firstSpace = sentence.index(of: <span class="string">""</span>) ?? sentence.endIndex</span><br><span class="line"><span class="keyword">let</span> firstWord = sentence[..&lt;firstSpace] <span class="comment">// →"The"</span></span><br><span class="line">type(of: firstWord) <span class="comment">// → Substring.Type</span></span><br></pre></td></tr></table></figure>

<p>切片操作不占用内存意义重大，特别是在一个循环中，比如你要通过循环访问整个字符串（可能会很长）来提取其中的字符。比如在文本中找到一个单词使用的次数，比如解析一个 CSV 文件。这里有一个非常有用的字符串处理操作：split。<code>split</code>是 <code>Collection</code> 集合中定义的一个方法，它会返回一个子序列的数组（即<code>[Substring]</code>）。它最常见的变种就像是这样：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Collection</span> <span class="title">where</span> <span class="title">Element</span>: <span class="title">Equatable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">split</span><span class="params">(separator: Element, maxSplits: Int = Int.<span class="built_in">max</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        omittingEmptySubsequences: Bool = <span class="literal">true</span>)</span></span> -&gt; [<span class="type">SubSequence</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可以这样使用：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> poem = <span class="string">"""</span></span><br><span class="line"><span class="string">    Over the wintry</span></span><br><span class="line"><span class="string">    forest, winds howl in rage</span></span><br><span class="line"><span class="string">    with no leaves to blow.</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">let</span> lines = poem.<span class="built_in">split</span>(separator: <span class="string">"\n"</span>)</span><br><span class="line"><span class="comment">// → ["Over the wintry", "forest, winds howl in rage", "with no leaves to blow."]</span></span><br><span class="line">type(of: lines) <span class="comment">// → Array&lt;Substring&gt;.Type</span></span><br></pre></td></tr></table></figure>

<p>这个跟 <code>String</code> 继承自 <code>NSString</code> 的 <a href="https://developer.apple.com/documentation/swift/stringprotocol/2923413-components" target="_blank" rel="noopener"><code>components(separatedBy:)</code></a> 方法的功能类似，你还可以用一些额外设置比如是否抛弃空的组件。而且在这个操作中，所有输入字符串都没有创建新的复制。因为还有其他 <code>split</code> 方法的变种可以完成操作，除了比较字符以外，<code>split</code>还可以完成更多的事情。下面这个例子是文本换行算法的一个原始的实现，最后的代码计算了行的长度：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">wrapped</span><span class="params">(after: Int = <span class="number">70</span>)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">let</span> lines = <span class="keyword">self</span>.<span class="built_in">split</span>(omittingEmptySubsequences: <span class="literal">false</span>) &#123;</span><br><span class="line">            character <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">switch</span> character &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"\n"</span>, <span class="string">""</span> <span class="keyword">where</span> i &gt;= after:</span><br><span class="line">                i = <span class="number">0</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lines.joined(separator: <span class="string">"\n"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sentence.wrapped(after: <span class="number">15</span>)</span><br><span class="line"><span class="comment">// →"The quick brown\nfox jumped over\nthe lazy dog."</span></span><br></pre></td></tr></table></figure>

<p>或者，考虑写另外一个版本，可以拿到一个包含多个分隔符的序列：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Collection</span> <span class="title">where</span> <span class="title">Element</span>: <span class="title">Equatable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">split</span>&lt;S: Sequence&gt;<span class="params">(separators: S)</span></span> -&gt; [<span class="type">SubSequence</span>]</span><br><span class="line">        <span class="keyword">where</span> <span class="type">Element</span> == <span class="type">S</span>.<span class="type">Element</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">split</span> &#123; separators.<span class="built_in">contains</span>($<span class="number">0</span>) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样的话，你还可以这么写：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"Hello, world!"</span>.<span class="built_in">split</span>(separators: <span class="string">",!"</span>) <span class="comment">// → ["Hello", "world"]</span></span><br></pre></td></tr></table></figure>

<h3 id="字符串协议 -StringProtocol"><a href="# 字符串协议 -StringProtocol" class="headerlink" title="字符串协议 StringProtocol"></a>字符串协议 <code>StringProtocol</code></h3><p><code>Substring</code>和 <code>String</code> 几乎有着相同的接口，因为两种类型都遵守一个共同的字符串协议（<a href="https://developer.apple.com/documentation/swift/stringprotocol" target="_blank" rel="noopener"><code>StringProtocol</code></a>）。因为几乎所有的字符串 API 都是在 <a href="https://developer.apple.com/documentation/swift/stringprotocol" target="_blank" rel="noopener"><code>StringProtocol</code></a> 中定义的，所以操作<code>Substring</code> 跟操作 <code>String</code> 没有什么大的区别。但是，在有些情况下，你还必须把子字符串转换为字符串的类型；就像所有的切片（slice）一样，子字符串只是为了短时间内的存储，为了防止一次操作定义太多个复制。如果操作结束之后，你还想保留结果，将数据传到另一个子系统里，你应该创建一个新的字符串。你可以用一个 <code>Substring</code> 的值初始化一个<code>String</code>，就像我们在这个例子中做的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lastWord</span><span class="params">(<span class="keyword">in</span> input: String)</span></span> -&gt; <span class="type">String?</span> &#123;</span><br><span class="line">    <span class="comment">// Process the input, working on substrings</span></span><br><span class="line">    <span class="keyword">let</span> words = input.<span class="built_in">split</span>(separators: [<span class="string">","</span>, <span class="string">""</span>])</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> lastWord = words.last <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">    <span class="comment">// Convert to String for return</span></span><br><span class="line">    <span class="keyword">return</span> <span class="type">String</span>(lastWord)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lastWord(<span class="keyword">in</span>: <span class="string">"one, two, three, four, five"</span>) <span class="comment">// →"five"</span></span><br></pre></td></tr></table></figure>

<p>不建议子字符串长期存储背后的原因是子字符串一直关联着原字符串。即使一个超长字符串的子字符串只有一个字符，只要子字符串还在使用，那原先的字符串就还会在内存里，即使原字符串的生命周期已经结束。因此，长期存储子字符串可能导致内存泄漏，因为有时候原字符串已经无法访问了，但是还在占用内存。</p>
<p>操作过程中使用子字符串，操作结束的时候才创建新的字符串，通过这种方式，我们把占用内存的动作推迟到了最后一刻，而且保证了我们只会创建必要的字符串。在上面的例子当中，我们把整个字符串（可能会很长）分成了一个个的子字符串，但是在最后只是创建了一个很短的字符串。（例子中的算法可能效率不是那么高，暂时忽略一下；从后先前找到第一个分隔符可能是个更好的方法。）</p>
<p>遇到只接受 <code>Substring</code> 类型的方法，但是你想传递一个 <code>String</code> 的类型，这种情况很少见（大部分的方法都接受 <code>String</code> 类型或者接受所有符合字符串协议的类型），但是如果你确实需要传递一个 <code>String</code> 的类型，最便捷的方法是使用范围操作符（range operator）<code>...</code>，不限定范围：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子字符串和原字符串的起始和结束的索引完全一致 </span></span><br><span class="line"><span class="keyword">let</span> substring = sentence[...]</span><br></pre></td></tr></table></figure>

<hr>
<p><code>Substring</code>类型是 Swift 4 中的新特性。在 Swift 3 中，<code>String.CharacterView</code>是自己独有的切片类型（slice type）。这么做的优势是用户只需要了解一种类型，但这也意味这如果存储一个子字符串，整个原字符串也会占据内存，即使它正常情况下应该已经被释放了。Swift 4 损失了一点便捷，换来的是的方便的切片操作和可预测的内存使用。</p>
<p>要求 <code>Substring</code> 到<code>String</code>的转换必须明确写出，Swift 团队认为这没那么烦人。如果实际应用中大家都觉得问题很大，他们也会考虑直接在编译器中写一个 <code>Substring</code> 和<code>String</code>之间的 <a href="https://github.com/apple/swift/blob/master/docs/StringManifesto.md#substrings" target="_blank" rel="noopener"> 模糊子类型关系（implicit subtype relationship）</a>，就像 <code>Int</code> 是<code>Optional&lt;Int&gt;</code>的子类型一样。这样你就可以随意传递 <code>Substring</code> 类型，编译器会帮你完成类型转换。</p>
<hr>
<p>你可能会倾向于充分利用字符串协议，把你所有的 API 写成接受所有遵守字符串协议的实例，而不是仅仅接受 <code>String</code> 字符串。但 Swift 团队的建议是，<a href="https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20170626/037828.html" target="_blank" rel="noopener">别这样</a>：</p>
<blockquote>
<p>总的来说，我们建议继续使用字符串变量。 使用字符串变量，大多数的 API 都会比把它们写成通用类型（这个操作本身就有一些代价）更加简洁清晰，用户在必要的时候进行一些转换并不需要花费很大的精力。</p>
</blockquote>
<p>一些 API 极有可能和子字符串一起使用，同时无法泛化到适用于整个序列 <code>Sequence</code> 或集合 <code>Collection</code> 的级别，这些 API 可以不受这条规则的限制。一个例子就是标准库中的 <a href="https://developer.apple.com/documentation/swift/sequence/1641243-joined" target="_blank" rel="noopener"><code>joined</code></a> 方法。Swift 4 中，针对遵守字符串协议的元素组成的序列（<code>Sequence</code>）添加了一个重载（overload）：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Sequence</span> <span class="title">where</span> <span class="title">Element</span>: <span class="title">StringProtocol</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// 两个元素中间加上一个特定分隔符后</span></span><br><span class="line">    <span class="comment">/// 合并序列中所有元素，返回一个新的字符串</span></span><br><span class="line">    <span class="comment">/// Returns a new string by concatenating the elements of the sequence,</span></span><br><span class="line">    <span class="comment">/// adding the given separator between each element.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">joined</span><span class="params">(separator: String = <span class="string">""</span>)</span></span> -&gt; <span class="type">String</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，你就可以直接对一个子字符串的数组调用 <code>joined</code> 方法了，没必要遍历一次数组并且把每个子字符串转换为新的字符串。这样，一切都很方便快速。</p>
<p>数值类型初始器（number type initializer）可以将字符串转换为一个数字。在 Swift 4 中，它也接受遵守字符串协议的值。如果你要处理一个子字符串的数组的话，这个方法很顺手：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> commaSeparatedNumbers = <span class="string">"1,2,3,4,5"</span></span><br><span class="line"><span class="keyword">let</span> numbers = commaSeparatedNumbers</span><br><span class="line">    .<span class="built_in">split</span>(separator: <span class="string">","</span>).flatMap &#123; <span class="type">Int</span>($<span class="number">0</span>) &#125;</span><br><span class="line"><span class="comment">// → [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>

<p>由于子字符串的生命周期很短，所以不建议方法的返回值是子字符串，除非是序列 <code>Sequence</code> 或集合 <code>Collection</code> 的一些返回切片的 API。如果你写了一个类似的方法，只对字符串有意义，那让它的返回值是子字符串，好让读者明白这个方法并不会产生复制，不会占用内存。创建新字符串的方法需要占用内存，比如 <a href="https://developer.apple.com/documentation/swift/stringprotocol/2908613-uppercased" target="_blank" rel="noopener"><code>uppercased()</code></a>，这类的方法应该返回 <code>String</code> 字符串类型的值。</p>
<p>如果你想为字符串类型扩展新的功能， 好的办法是将扩展放在字符串协议 <code>StringProtocol</code> 上，保证 API 在字符串和子字符串层面的一致性。字符权协议的设计初衷就是替换原先在字符串基础上做的扩展功能。如果你想把现有的扩展从字符串转移到字符串协议上，你要做的唯一改变就是，把传递 <code>Self</code> 给只接受具体 <code>String</code> 值的 API 替换为<code>String(Self)</code>。</p>
<p>需要记住的一点是，从 Swift 4 开始，如果你有一些自定义的字符串类型，不建议遵守字符串协议<code>StringProtocol</code>。官方文档明确警告：</p>
<blockquote>
<p>不要做任何新的遵守字符串协议 <code>StringProtocol</code> 的声明。只有标准库里的 <code>String</code> 和<code>Substring</code>是有效的遵守类型。</p>
</blockquote>
<p>允许开发者写自己的字符串类型（比如有特殊的存储优化或性能优化）是终极目标，但是现阶段协议的设计还没有最终确定，所以现在就启用它可能会导致你的代码在 Swift 5 里无法正常运行。</p>
<p><em>… <SNIP>  &lt; 内容有删减 &gt;…</em></p>
<h2 id="总结"><a href="# 总结" class="headerlink" title="总结"></a>总结 </h2><p>Swift 语言里的字符串跟其他所有的主流编程语言里的字符串差异很大。当你习惯于把字符串当做代码块的数组后，你得花点时间转化思维，习惯 Swift 的处理方法：它把遵守 Unicode 编码标准放在<strong> 简洁 </strong> 前面。</p>
<p>总的来讲，我们认为 Swift 的选择是正确的。Unicode 编码文本比其他编程语言所认为的要复杂得多。长远来看，处理你可能写出来的 bug 的时间肯定比学习新的索引方式（忘记整数索引）所需的时间多。</p>
<p>我们已经习惯于任意获取“字符”，以至于我们都忘了其实这个特性在真正的字符串处理的代码里很少用到。我们希望通过这一章里的例子可以说服大家，对于大多数常规的操作，简单的按序遍历也完全 OK。强迫你清楚地写出你想在哪个层面（字素集，Unicode scalar，UTF-16 代码块，UTF-8 代码块）处理字符串是另一项安全措施；读你代码的人会对你心存感激的。</p>
<p>2016 年 7 月，Chris Lattner 谈到了 <a href="https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160725/025676.html" target="_blank" rel="noopener">Swift 语言字符串处理的目标</a>，他最后是这么说的：</p>
<blockquote>
<p>我们的目标是在字符串处理上超越 Perl。</p>
</blockquote>
<p>当然 Swift 4 还没有实现这个目标——很多想要的特性还没实现，包括把 Foundation 库中的诸多字符串 API 转移到标准库，正则表达式的自然语言支持，字符串格式化和解析 API，更强大的字符串插入功能。好消息是 Swift 团队已经表示 <a href="https://github.com/apple/swift/blob/master/docs/StringManifesto.md" target="_blank" rel="noopener">会在将来解决所有这些问题</a>。</p>
<hr>
<p>如果喜欢本文的话，请考虑 <a href="https://gumroad.com/a/507458675" target="_blank" rel="noopener"> 购买全书</a>。谢谢！</p>
<p>全书中第一张是本文的两本。讨论了其他的一些问题，包括如何使用以及什么时候使用字符串的代码块视图，如何和 Foundation 里的处理字符串的 API（例如 <a href="https://developer.apple.com/documentation/foundation/nsregularexpression" target="_blank" rel="noopener"><code>NSRegularExpression</code></a>或者 <a href="https://developer.apple.com/documentation/foundation/nsattributedstring" target="_blank" rel="noopener"><code>NSAttributedString</code></a>） 配合处理。贴别是后面这个问题很难，而且很容易犯错。除此之外还讨论了其他标准库里面机遇字符串的 API，例如文本输出流（<a href="https://developer.apple.com/documentation/swift/textoutputstream" target="_blank" rel="noopener"><code>TextOutputStream</code></a>）或自定义字符串转换（<a href="https://developer.apple.com/documentation/swift/customstringconvertible" target="_blank" rel="noopener"> <code>CustomStringConvertible</code></a>）。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/28/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/28/">28</a><span class="page-number current">29</span><a class="page-number" href="/page/30/">30</a><span class="space">&hellip;</span><a class="page-number" href="/page/36/">36</a><a class="extend next" rel="next" href="/page/30/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Dali Khan"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">Dali Khan</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">143</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">233</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="mailto:ross4han@gmail.com" title="E-Mail → mailto:ross4han@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/p/1005052736192503" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;p&#x2F;1005052736192503" rel="noopener" target="_blank"><i class="fa fa-fw fa-weibo"></i>Weibo</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/dearbojack" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;dearbojack" rel="noopener" target="_blank"><i class="fa fa-fw fa-twitter"></i>Twitter</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://instagram.com/dearbojack" title="Instagram → https:&#x2F;&#x2F;instagram.com&#x2F;dearbojack" rel="noopener" target="_blank"><i class="fa fa-fw fa-instagram"></i>Instagram</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/cn" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2017 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Dali Khan</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
